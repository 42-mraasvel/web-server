Config
	- read config file, generate one class_Config (class_ ConfigServer for each server)

Setup Server
	- for server
		- each port: socket -> bind -> listen (error checking)

Poll loop
	- write event 
		- connection
		- file
		- TBD
	- read event(table& fds)
		- Adds FD to table
		- server
		- connection
		- file
		- TBD
	- close event(table& fds)
		- Erases FD from table

ServerFd:
	POLLIN: wait for incoming connection requests

ClientFd:
	START:
		POLLIN: wait for incoming request
		NOTHING: wait for response to become ready
		POLLOUT: send response
		CLOSING: Next iteration, we should close this FD
		Check if connection has to be closed
	goto START;

ClientSide:
	START:
		POLLOUT: send request
		POLLIN: read response
	goto START;


Opening a file:
	Client:
		Initialize the file(client_index) (target resource), add it to the table

	File:
		read/write from file until finished
		Update itself to WAITING
		Update client to WRITING
	
	Client:
		WritingEvent:
			Extract content from file, create response
			Set File STATUS to TO_ERASE


TODO:
	Configuration File:
		Syntax (language form: copy nginx) (ABNF?)
		List everything that needs to be present
		Parse it to the config class instance

	RequestParser(FULL_REQUEST)
		RequestLine (Method, Target-resoruce, Version)
		Headerfields (hash table, map)
		Message-body

	Executor:
		Implement each method
		(GET, POST, DELETE)
		Error responses
		GET:
			1. Open file, add to POLLFDS
			2. Read in file content completely
			3. Generate respones, signal client to start writing response

		Optimization: Concurrently sending response while reading in message-body using Chunked response

	Client:
		Check if request has been fully read, whether or not we need to do more
		Update readEvent to be dynamic

	CGI:
		Configuration file input
		Execution
		Output redirection (piping)
